

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>C-xtlang interop &mdash; Extempore 0.7.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Extempore 0.7.0 documentation" href="index.html"/>
        <link rel="next" title="Scheme-xtlang interop" href="scheme-xtlang-interop.html"/>
        <link rel="prev" title="Time in Extempore" href="time.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Extempore
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="editor-support.html">Text editors</a></li>
<li class="toctree-l1"><a class="reference internal" href="about-this-documentation.html">About this documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Key concepts</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="philosophy.html">The Extempore philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="caas.html">Interacting with the Extempore Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="time.html">Time in Extempore</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">C-xtlang interop</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#xtlang-c-interaction">xtlang-C interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#foolib-the-world-s-most-useless-c-library">Foolib: the world&#8217;s most useless C library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kissfft-a-more-useful-library">KissFFT: a more useful library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-external-directory">The external directory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scheme-xtlang-interop.html">Scheme-xtlang interop</a></li>
<li class="toctree-l1"><a class="reference internal" href="concurrency.html">Concurrency</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Memory management in Extempore</a></li>
</ul>
<p class="caption"><span class="caption-text">xtlang</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="types.html">xtlang types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#primitive-types">Primitive types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#aggregate-types">Aggregate types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#named-types">Named types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-inference.html">Type inferencing</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best practices</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials &amp; Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="audio-signal-processing.html">Audio signal processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="making-an-instrument.html">Making an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="note-level-music.html">Playing an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-lisp-music.html">&#8220;Common Lisp Music&#8221;-style example</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampler.html">Loading and using a sampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphics.html">Graphics</a></li>
<li class="toctree-l1"><a class="reference internal" href="impromptu-users.html">Extempore for Impromptu users</a></li>
</ul>
<p class="caption"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting-help.html">Getting Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Unit testing in Extempore</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Extempore</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>C-xtlang interop</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/c-xtlang-interop.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="c-xtlang-interop">
<h1>C-xtlang interop<a class="headerlink" href="#c-xtlang-interop" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This was once a blog post&#8212;corrections/improvements
welcome.</p>
</div>
<p>There&#8217;s a <em>lot</em> of useful C library code out there. Sometimes there
<em>are</em> good reasons to write things from scratch, but other times you
find the exact thing you&#8217;re looking for on GitHub and you just want to
link against it and then go home to watch the footy.</p>
<p>Most languages (both high and low-level) provide some sort of <a class="reference external" href="http://en.wikipedia.org/wiki/Foreign_function_interface">foreign
function interface</a> (FFI) to C. Different languages provide this
functionality in different ways, but at the end of the day the aim is to
be able to call external C code from within the language, and xtlang
provides a way to do this.</p>
<p>The reasons for binding to C library code are different in xtlang than
they are in other languages, particularly &#8216;scripting&#8217; languages like
Perl or Ruby. In those languages, it&#8217;s often for performance
reasons&#8212;there&#8217;s a certain hot loop of the code, and rewriting it in C
can give a huge performance win. xtlang, on the other hand, is <em>already</em>
high performance, because of its native compilation via LLVM, so
rewriting bits in C isn&#8217;t usually of any benefit. The main reason you&#8217;ll
want to call C code from xtlang, then, is to take advantage of existing
libraries.</p>
<div class="section" id="xtlang-c-interaction">
<h2>xtlang-C interaction<a class="headerlink" href="#xtlang-c-interaction" title="Permalink to this headline">¶</a></h2>
<p>In some ways, mixing xtlang code and C code is easy. The type system is
quite similar: all of xtlang&#8217;s floats and ints have a C counterpart
which is exactly the same. Tuples are the same as C structs, and
xtlang&#8217;s arrays are the same as C arrays. These type equivalences aren&#8217;t
just conceptual or semantic&#8212;they&#8217;re the exact same bit patterns in
memory.</p>
<p>Also, both languages have pointer types, and deal with manual memory
management via pointers. Both have a static type system which allows the
compiler to throw errors at compile time if the types don&#8217;t all match
up. So there are some good reasons why C and xtlang should play nicely
together.</p>
<p>Having said that, there are some key differences between C and xtlang. C
is the archetype of the &#8216;static language&#8217;, while xtlang is designed to
allow the programmer to redefine core parts of the program <em>while it is
executing</em> (see <a class="reference internal" href="philosophy.html"><span class="doc">The Extempore philosophy</span></a> for more details).
Extempore supports REPL-style development, with the programmer
interacting with the source code, evaluating and compiling parts of it
in a non-linear fashion, and then modifying and recompiling it as
necessary. There are a few quirky projects which allow this type of
development with C, but in general you build the whole project, then
ship the resulting binary.</p>
<p>So how <em>does</em> xtlang support binding and calling C code dynamically
from xtlang code? The basic answer is though shared (dynamic)
libraries. To recap, C libraries can either be statically compiled
into an application, or dynamically linked in at run-time. There are
pros and cons to both approaches, and so C libraries can be compiled
either statically or dynamically (by setting a compiler flag).</p>
<p>To call a C library from xtlang involves creating an xtlang &#8216;header&#8217;,
which lets the xtlang compiler know about the types and function
signatures in C library&#8217;s header. I&#8217;m using the term <em>header</em> in
quotes because it doesn&#8217;t have to be its own source file, there are no
restrictions on naming, etc. It&#8217;s just regular xtlang code that needs
to be evaluated before you can use the functions in the library.
Extempore can then load the shared library, xtlang can call functions
in the library, and it should all be peaches.</p>
</div>
<div class="section" id="foolib-the-world-s-most-useless-c-library">
<h2>Foolib: the world&#8217;s most useless C library<a class="headerlink" href="#foolib-the-world-s-most-useless-c-library" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s consider a really simple example. Say we have a C library which
only defines <em>one function</em> called <code class="docutils literal"><span class="pre">foo</span></code>. This library (libfoo) will
have a header</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* libfoo.h */</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">bar</span><span class="p">);</span>
</pre></div>
</div>
<p>and an implementation</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* libfoo.c */</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">bar</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">bar</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Not the most useful library in the world, to be sure, but let&#8217;s compile
it as a shared library anyway. Shared libraries have different file
extensions on the different platforms that Extempore runs on:</p>
<ul class="simple">
<li><strong>OSX</strong>: <code class="docutils literal"><span class="pre">libname.dylib</span></code></li>
<li><strong>Linux</strong>: <code class="docutils literal"><span class="pre">libname.so</span></code></li>
<li><strong>Windows</strong>: <code class="docutils literal"><span class="pre">libname.dll</span></code></li>
</ul>
<p>If you compile the library yourself, in general you should get the right
type of binary for your platform. If you&#8217;ve just downloaded the
<code class="docutils literal"><span class="pre">.dylib</span></code> (or <code class="docutils literal"><span class="pre">.so</span></code>, or <code class="docutils literal"><span class="pre">.dll</span></code>) from the interwebs, though, you
need to be careful that the binary file was compiled for the platform
you&#8217;re on. It&#8217;s not just a matter of renaming the file to right file
extension, either: the guts of the file are different between the
platforms as well.</p>
<p>From here on I&#8217;ll assume you&#8217;re on OSX, so I&#8217;ll refer to libraries with the
<code class="docutils literal"><span class="pre">.dylib</span></code> extension, but just substitute in the appropriate extension
for your platform. To build the shared library on OSX, move into
libfoo&#8217;s directory and build it with the <code class="docutils literal"><span class="pre">-dynamiclib</span></code> flag:</p>
<div class="code highlight-default"><div class="highlight"><pre><span class="n">clang</span> <span class="n">libfoo</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">dynamiclib</span> <span class="o">-</span><span class="n">o</span> <span class="n">libfoo</span><span class="o">.</span><span class="n">dylib</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">clang</span></code> is a C compiler that&#8217;s part of the LLVM project. I could also
have used <code class="docutils literal"><span class="pre">gcc</span></code> or some other compiler.</p>
<p>After running the above command, the file <code class="docutils literal"><span class="pre">libfoo.dylib</span></code> will appear
in the directory&#8212;a binary file which contains the instructions for how
to perform the functions provided by the library (in this case just the
function <code class="docutils literal"><span class="pre">foo</span></code>). This is the <em>shared</em> or <em>dynamic</em> library.</p>
<p>Once the shared library is compiled, the only thing to do before it&#8217;s
callable from xtlang code is to tell xtlang compiler about the type
signature of the functions in the library. To do this, we use
<code class="docutils literal"><span class="pre">bind-lib</span></code>.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; libfoo.xtm -- an xtm header for libfoo</span>

<span class="c1">;; load the shared lib</span>
<span class="p">(</span><span class="k">bind-dylib</span> <span class="nf">libfoo</span> <span class="s">&quot;libfoo.dylib&quot;</span><span class="p">)</span>

<span class="c1">;; define foo as a function</span>
<span class="p">(</span><span class="k">bind-lib</span> <span class="nf">libfoo</span> <span class="nv">foo</span> <span class="kt">[i64,i64]*</span><span class="p">)</span>

<span class="c1">;; test that everything worked ok</span>
<span class="p">(</span><span class="k">bind-func</span> <span class="nf">foo_test</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;foo(x) = %lld\n&quot;</span> <span class="p">(</span><span class="nv">foo</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">foo_test</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">;; prints &quot;foo(x) = 48&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">bind-dylib</span></code> is the Extempore interface for loading shared
libraries. To find the library, it first looks for one of that name in
the directory in which the Extempore process is running. After that,
it&#8217;ll look on your system&#8217;s library path. <code class="docutils literal"><span class="pre">bind-dylib</span></code> has a
return value, which in the example above is bound to the symbol
<code class="docutils literal"><span class="pre">libfoo</span></code>. It&#8217;s important to capture this return value, because we&#8217;ll
need it shortly with <code class="docutils literal"><span class="pre">bind-lib</span></code>.</p>
<p>In <code class="docutils literal"><span class="pre">libfoo.xtm</span></code> (above), <code class="docutils literal"><span class="pre">bind-lib</span></code> is really only declaring that
&#8220;there is a C function called <code class="docutils literal"><span class="pre">foo</span></code> in the shared library <code class="docutils literal"><span class="pre">libfoo</span></code>,
and it takes one <code class="docutils literal"><span class="pre">i64</span></code> argument and returns an <code class="docutils literal"><span class="pre">i64</span></code>.</p>
<p>But hang on a sec&#8212;if <code class="docutils literal"><span class="pre">foo</span></code> is a C <em>function</em>, why does it have the
type signature (square brackets) of an xtlang <em>closure</em>? Well, this
is a bit of a cheat on xtlang&#8217;s part&#8212;the bound function <code class="docutils literal"><span class="pre">foo</span></code> <em>is</em>
just the plain C function from the library. But we do have to specify
its type signature (argument and return types), and because xtlang
doesn&#8217;t provide a syntax for functions (only closures), then
<code class="docutils literal"><span class="pre">bind-val</span></code> just takes a closure signature and interprets it as a
function signature (which are the same).</p>
<p>It really is just a C function, though, and there is <strong>no performance
penalty</strong> for calling C functions in xtlang code. This is because
there&#8217;s no wrapper functions or anything like that that have to operate
as a bridge between the xtlang code, and the argument and return types
have exact (bit-identical) xtlang counterparts, so there&#8217;s really no
hard work to do (in contrast to higher level languages, which have to
worry about boxing/unboxing numeric types, for example).</p>
</div>
<div class="section" id="kissfft-a-more-useful-library">
<h2>KissFFT: a more useful library<a class="headerlink" href="#kissfft-a-more-useful-library" title="Permalink to this headline">¶</a></h2>
<p>As a more useful example, let&#8217;s look at the library <code class="docutils literal"><span class="pre">fft.xtm</span></code> in the
<code class="docutils literal"><span class="pre">libs/external</span></code> directory which comes with Extempore. <code class="docutils literal"><span class="pre">fft.xtm</span></code> uses
the excellent <a class="reference external" href="http://sourceforge.net/projects/kissfft/">KissFFT</a> library for doing <a class="reference external" href="http://en.wikipedia.org/wiki/Fourier_transform">Fourier transforms</a>. The
library is quite small and clean, and is spread over only a few source
files&#8212;the main ones being <code class="docutils literal"><span class="pre">kiss_fft.h</span></code> &amp; <code class="docutils literal"><span class="pre">kiss_fft.c</span></code>. There&#8217;s gonna
be a bit of C in this section. Nothing too complicated, but if you&#8217;re
rusty it might be worth picking up a copy of <a class="reference external" href="http://www.iu.hio.no/~mark/CTutorial/CTutorial.html">K&amp;R</a> or your to flip
through if necessary.</p>
<p>If you&#8217;re playing along at home, then you&#8217;ll need to download the
<a class="reference external" href="https://github.com/extemporelang/kiss_fft">KissFFT source</a>, build the <code class="docutils literal"><span class="pre">kiss_fft.dylib</span></code> library and put it somewhere
that <code class="docutils literal"><span class="pre">bind-dylib</span></code> will find it. The <code class="docutils literal"><span class="pre">fft.xtm</span></code> header has some
instructions on how to do this.</p>
<p>After that&#8217;s done, then it&#8217;s a matter of providing <code class="docutils literal"><span class="pre">bind-lib</span></code> xtlang
definitions which tell Extempore about the functions in
<code class="docutils literal"><span class="pre">kiss_fft.dylib</span></code>. But how do we know what those functions are? Well,
we need to look at the <code class="docutils literal"><span class="pre">kiss_fft.h</span></code> header file.</p>
<p>A Fourier transform (FT) &#8220;expresses a mathematical function of time as a
function of frequency, known as its frequency spectrum&#8221; (from
<a class="reference external" href="http://en.wikipedia.org/wiki/Fourier_transform">Wikipedia</a>). But don&#8217;t worry if you don&#8217;t understand the maths behind
the FT for the purposes of this example, just know that we want to give
it a buffer of input values and have it give us back a buffer of
transformed output values. Looking through the header, it&#8217;s clear that
the function we call to do this is <code class="docutils literal"><span class="pre">kiss_fft</span></code>.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kiss_fft(cfg,in_out_buf)</span>
<span class="cm"> *</span>
<span class="cm"> * Perform an FFT on a complex input buffer.</span>
<span class="cm"> * for a forward FFT,</span>
<span class="cm"> * fin should be  f[0] , f[1] , ... ,f[nfft-1]</span>
<span class="cm"> * fout will be   F[0] , F[1] , ... ,F[nfft-1]</span>
<span class="cm"> * Note that each element is complex and can be accessed like</span>
<span class="cm">    f[k].r and f[k].i</span>
<span class="cm"> * */</span>

<span class="kt">void</span> <span class="nf">kiss_fft</span><span class="p">(</span><span class="n">kiss_fft_cfg</span> <span class="n">cfg</span><span class="p">,</span><span class="k">const</span> <span class="n">kiss_fft_cpx</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span><span class="n">kiss_fft_cpx</span> <span class="o">*</span><span class="n">fout</span><span class="p">);</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">kiss_fft</span></code> returns <code class="docutils literal"><span class="pre">void</span></code> (doesn&#8217;t return a useful
value) and takes three arguments:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">cfg</span></code> (of type <code class="docutils literal"><span class="pre">kiss_fft_cfg</span></code>)</li>
<li><code class="docutils literal"><span class="pre">fin</span></code> (of type <code class="docutils literal"><span class="pre">kiss_fft_cpx*</span></code>)</li>
<li><code class="docutils literal"><span class="pre">fout</span></code> (also of type <code class="docutils literal"><span class="pre">kiss_fft_cpx*</span></code>)</li>
</ul>
<p>This header file is well commented, and it&#8217;s clear that</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">cfg</span></code> is some configuration data for the algorithm</li>
<li><code class="docutils literal"><span class="pre">fin</span></code> should be a pointer to our input buffer</li>
<li><code class="docutils literal"><span class="pre">fout</span></code> should be a pointer to the output buffer</li>
</ul>
<p>Why do we pass a pointer to the output buffer in to the function? If we
already know what the output is, why are we calling the function at all?
The answer (and the clue is in the fact that the function returns
<code class="docutils literal"><span class="pre">void</span></code>) is that <code class="docutils literal"><span class="pre">fout</span></code> should point to a buffer where <code class="docutils literal"><span class="pre">kiss_fft</span></code>
will store the output values. Whatever data is in that buffer before the
function is called will be overwritten, so it had better not be
important.</p>
<p>Why is the library written this way? Well, one of the key benefits of
this &#8220;pass in a location for the answer to be written to&#8221; approach is
that the memory with the answer in it can be managed by the calling
function (that is, the function which calls <code class="docutils literal"><span class="pre">kiss_fft</span></code>). As
discussed in the <a class="reference internal" href="memory.html"><span class="doc">Memory management in Extempore</span></a>, the explicit nature of memory
allocation and deallocation in xtlang (and in C) gives the programmer
great control over the lifetime of any memory the program allocates.
The function which <em>calls</em> <code class="docutils literal"><span class="pre">kiss_fft</span></code> will have a much better idea
of what it wants to do with the output values than <code class="docutils literal"><span class="pre">kiss_fft</span></code> does,
so it makes sense to have this calling function allocate some memory
of the appropriate size and type, and then just pass in a pointer to
this memory in <code class="docutils literal"><span class="pre">fout</span></code>.</p>
<p>So now we can just go ahead and turn the signature of <code class="docutils literal"><span class="pre">kiss_fft</span></code>
into a <code class="docutils literal"><span class="pre">bind-lib</span></code> and we&#8217;re done, right? Something like (remembering
that xtlang uses <code class="docutils literal"><span class="pre">i8*</span></code> in place of C&#8217;s <code class="docutils literal"><span class="pre">void</span></code> type)</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">kissfft</span> <span class="p">(</span><span class="k">bind-dylib</span> <span class="s">&quot;kiss_fft.dylib&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">bind-lib</span> <span class="nf">kissfft</span> <span class="nv">kiss_fft</span> <span class="kt">[i8*,kiss_fft_cfg,kiss_fft_cpx*,kiss_fft_cpx*]*</span><span class="p">)</span>
</pre></div>
</div>
<p>But then when we try and evaluate the <code class="docutils literal"><span class="pre">bind-lib</span></code>, the compiler throws
an error:</p>
<div class="code highlight-default"><div class="highlight"><pre><span class="n">Compiler</span> <span class="n">Error</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">find</span> <span class="nb">type</span> <span class="k">for</span> <span class="s2">&quot;kiss_fft_cfg&quot;</span>
</pre></div>
</div>
<p>Ah, Extempore can&#8217;t recognise the type signature for <code class="docutils literal"><span class="pre">kiss_fft</span></code>
without knowing about all its argument and return types as well. So,
let&#8217;s dive back into the <code class="docutils literal"><span class="pre">kiss_fft.h</span></code> header file to find the
declaration of <code class="docutils literal"><span class="pre">kiss_fft_cfg</span></code>.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* in kiss_fft.h */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">kiss_fft_state</span><span class="o">*</span> <span class="n">kiss_fft_cfg</span><span class="p">;</span>
</pre></div>
</div>
<p>So it seems that <code class="docutils literal"><span class="pre">kiss_fft_cfg</span></code> is actually <code class="docutils literal"><span class="pre">typedef</span></code> as a
pointer to the struct <code class="docutils literal"><span class="pre">kiss_fft_state</span></code>. A <code class="docutils literal"><span class="pre">typedef</span></code> is just like a
<code class="docutils literal"><span class="pre">bind-alias</span></code> in xtlang: the compiler doesn&#8217;t know anything about it,
it just looks like the type it points to. So the function <code class="docutils literal"><span class="pre">kiss_fft</span></code>
is really expecting <code class="docutils literal"><span class="pre">kiss_fft_state*</span></code> to be the type of its first
argument. We need to find the definition of <em>this</em> type.</p>
<p>Hmm, it&#8217;s not in <code class="docutils literal"><span class="pre">kiss_fft.h</span></code>. A look in <em>all</em> the header files in the
KissFFT source directory (with <code class="docutils literal"><span class="pre">grep</span> <span class="pre">kiss_fft_state</span> <span class="pre">*.h</span></code>) reveals that
it&#8217;s actually defined in <code class="docutils literal"><span class="pre">_kiss_fft_guts.h</span></code>.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* in _kiss_fft_guts.h */</span>

<span class="k">struct</span> <span class="n">kiss_fft_state</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">nfft</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">inverse</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">factors</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">MAXFACTORS</span><span class="p">];</span>
    <span class="n">kiss_fft_cpx</span> <span class="n">twiddles</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>So the <code class="docutils literal"><span class="pre">kiss_fft_state</span></code> struct has four members:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">nfft</span></code> (an <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li><code class="docutils literal"><span class="pre">inverse</span></code> (an <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li><code class="docutils literal"><span class="pre">factors</span></code> (an <code class="docutils literal"><span class="pre">int</span></code> array of length <code class="docutils literal"><span class="pre">2</span></code> ×=MAXFACTORS=)</li>
<li><code class="docutils literal"><span class="pre">twiddles</span></code> (a <code class="docutils literal"><span class="pre">kiss_fft_cpx</span></code> array of length <code class="docutils literal"><span class="pre">1</span></code>)</li>
</ul>
<p>Earlier in that header <code class="docutils literal"><span class="pre">MAXFACTORS</span></code> is defined to be 32, so the
<code class="docutils literal"><span class="pre">factos</span></code> array will be of length <code class="docutils literal"><span class="pre">64</span></code>. Also, in <code class="docutils literal"><span class="pre">twiddles</span></code>, the
<code class="docutils literal"><span class="pre">kiss_fft_cpx</span></code> type is new&#8212;we haven&#8217;t found a definition for it yet.
So we need to do that before we can tell the xtlang compiler about the
<code class="docutils literal"><span class="pre">kiss_fft_state</span></code> struct.</p>
<p>The <code class="docutils literal"><span class="pre">kiss_fft_cpx</span></code> definition is back in <code class="docutils literal"><span class="pre">kiss_fft.h</span></code></p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* in kiss_fft.h */</span>

<span class="cp">#ifdef FIXED_POINT</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp"># if (FIXED_POINT == 32)</span>
<span class="cp">#  define kiss_fft_scalar int32_t</span>
<span class="cp"># else</span>
<span class="cp">#  define kiss_fft_scalar int16_t</span>
<span class="cp"># endif</span>
<span class="cp">#else</span>
<span class="cp"># ifndef kiss_fft_scalar</span>
<span class="cm">/*  default is float */</span>
<span class="cp">#   define kiss_fft_scalar float</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">kiss_fft_scalar</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">kiss_fft_scalar</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="n">kiss_fft_cpx</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">kiss_fft_state</span><span class="o">*</span> <span class="n">kiss_fft_cfg</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">kiss_fft_cpx</span></code> is itself a struct with two values, <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">i</span></code>,
which are both of type <code class="docutils literal"><span class="pre">kiss_fft_scalar</span></code>. Looking at the top part of
that code, the type of <code class="docutils literal"><span class="pre">kiss_fft_scalar</span></code> depends on how the library
was compiled (all those <code class="docutils literal"><span class="pre">#ifdef</span></code> checks are performed at compile
time). In this case (and you can either trust me or check for yourself),
we didn&#8217;t pass any options for a fixed-point version of the library or
anything special, so <code class="docutils literal"><span class="pre">kiss_fft_scalar</span></code> will have the &#8216;default&#8217; type of
<code class="docutils literal"><span class="pre">float</span></code>.</p>
<p><code class="docutils literal"><span class="pre">kiss_fft_cpx</span></code> is therefore a struct of two floats. This makes sense
given our knowledge of what the struct is designed to represent: a
complex number. The two <code class="docutils literal"><span class="pre">float</span></code> members are for the real (<code class="docutils literal"><span class="pre">r</span></code>) and
imaginary (<code class="docutils literal"><span class="pre">i</span></code>) part of the complex number.</p>
<p>Now, finally, we know all the types we need to call <code class="docutils literal"><span class="pre">kiss_fft</span></code>. We
just need to tell the xtlang compiler about them.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; in fft.xtm</span>

<span class="p">(</span><span class="k">bind-type</span> <span class="nf">kiss_fft_cpx</span> <span class="kt">&lt;float,float&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">bind-type</span> <span class="nf">kiss_fft_state</span> <span class="kt">&lt;i32,i32,|64,i32|,|1,kiss_fft_cpx|&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">bind-alias</span> <span class="nf">kiss_fft_cfg</span> <span class="kt">kiss_fft_state*</span><span class="p">)</span>

<span class="p">(</span><span class="k">bind-lib</span> <span class="nf">kissfft</span> <span class="nv">kiss_fft</span> <span class="kt">[i8*,kiss_fft_cfg,kiss_fft_cpx*,kiss_fft_cpx*]*</span><span class="p">)</span>
</pre></div>
</div>
<p>See how each struct in C gets bound as a type in xtlang? If you don&#8217;t
believe me, go and have a look at the struct definitions above&#8212;they
should match up perfectly. We can now create tuples of type
<code class="docutils literal"><span class="pre">kiss_fft_cpx</span></code> in xtlang just like we would any other tuple, and in
fact we&#8217;ll <em>have to</em> if we want to actually call the functions from the
library.</p>
<p>So after all this detective work, finding and declaring the appropriate
type signatures, the above code finally compiles:</p>
<div class="code highlight-default"><div class="highlight"><pre><span class="n">Bound</span> <span class="n">kiss_fft_cpx</span> <span class="o">&gt;&gt;&gt;</span> <span class="o">&lt;</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="o">&gt;</span>
<span class="n">Bound</span> <span class="n">kiss_fft_state</span> <span class="o">&gt;&gt;&gt;</span> <span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">,</span><span class="o">|</span><span class="mi">64</span><span class="p">,</span><span class="n">i32</span><span class="o">|</span><span class="p">,</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span><span class="n">kiss_fft_cpx</span><span class="o">|&gt;</span>
<span class="n">Aliased</span> <span class="n">kiss_fft_cfg</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">kiss_fft_state</span><span class="o">*</span>
<span class="n">Bound</span> <span class="n">kiss_fft</span> <span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i8</span><span class="o">*</span><span class="p">,</span><span class="n">kiss_fft_cfg</span><span class="p">,</span><span class="n">kiss_fft_cpx</span><span class="o">*</span><span class="p">,</span><span class="n">kiss_fft_cpx</span><span class="o">*</span><span class="p">]</span><span class="o">*</span>
</pre></div>
</div>
<p>There are a few more functions in the actual <code class="docutils literal"><span class="pre">fft.xtm</span></code> file which I
haven&#8217;t included here: helper functions for setting up the
<code class="docutils literal"><span class="pre">kiss_fft_cfg</span></code> struct, determining efficient FFT stride lengths and
other things like that. You don&#8217;t have to <code class="docutils literal"><span class="pre">bind-lib</span></code> all the functions
in the library, just the ones you need, although knowing which ones
sometimes more of an art than a science. If the library has a well
defined <a class="reference external" href="http://en.wikipedia.org/wiki/Application_programming_interface">API</a> then it might be clear exactly how to get what you want
out of the library, but sometimes it just takes a bit of digging around
and looking at the code. In general, the approach I&#8217;ve taken here of
&#8220;find the function you want to call first, then work backwards to define
all the necessary types and helper functions&#8221; is probably not a bad one.</p>
</div>
<div class="section" id="the-external-directory">
<h2>The external directory<a class="headerlink" href="#the-external-directory" title="Permalink to this headline">¶</a></h2>
<p>If you&#8217;ve looked around the extempore <code class="docutils literal"><span class="pre">examples</span></code> or <code class="docutils literal"><span class="pre">libs</span></code>
directory, you might have noticed that there are <code class="docutils literal"><span class="pre">core</span></code>, <code class="docutils literal"><span class="pre">external</span></code>
and <code class="docutils literal"><span class="pre">contrib</span></code> subdirectories in each one. The reason for the
core/external distinction is that any <code class="docutils literal"><span class="pre">.xtm</span></code> file which doesn&#8217;t
require binding to an external C library goes in <code class="docutils literal"><span class="pre">core</span></code>, and any
<code class="docutils literal"><span class="pre">.xtm</span></code> file that <em>does</em> call into a shared library goes in
<code class="docutils literal"><span class="pre">external</span></code>. <code class="docutils literal"><span class="pre">contrib</span></code> is for platform-dependent things, such as the
Kinect library.</p>
<p>Everything in these folders is honest-to-goodness xtlang code just like
you could write yourself, and if you want to change anything in these
libraries you can do it on the fly, just as you can with any other
xtlang code. This is pretty cool&#8212;there&#8217;s something exciting about being
able to hack on the standard library while your code is running.</p>
<p>They&#8217;re also a great place to explore and get ideas for your own xtlang
code. And if you do end up writing a cool library (or xtlang bindings
for a cool C shared library) then submit a pull request and we&#8217;ll see if
we can get it included in the main Extempore distribution.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="scheme-xtlang-interop.html" class="btn btn-neutral float-right" title="Scheme-xtlang interop" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="time.html" class="btn btn-neutral" title="Time in Extempore" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Andrew Sorensen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>